# 常见算法题

## 1、最长公共子串算法

查找字符串数组中所有字符串共有的最长连续子串。

### 代码实现

```ts
const longestCommonSubstring = (strings: string[]): string => {
  if (!Array.isArray(strings) || strings.length === 0) return "";
  // 如果数组只有一个字符串，那它本身就是“公共子串”
  if (strings.length === 1) return strings[0];

  const base = strings.reduce((prev, curr) => {
    if (prev.length < curr.length) {
      return prev;
    } else {
      return curr;
    }
  });
  const len = base.length;
  for (let length = len; length > 0; length--) {
    for (let start = 0; start <= len - length; start++) {
      const substr = base.substring(start, start + length);
      if (strings.every((str) => str.includes(substr))) {
        return substr;
      }
    }
  }

  return "";
};

// 测试
const arr = ["abcdfg", "abcf", "abcfghrewq"];
const result = longestCommonSubstring(arr);
console.log("最长公共子串:", result); // 输出: "abc"
```

## 2、实现Promise.all

### 代码实现

```ts
function myPromiseAll(iterable: Iterable<any> | ArrayLike<any>) {
  // 1. 检查参数是否可迭代（简化处理：要求是数组）
  if (!Array.isArray(iterable)) {
    return Promise.reject(new TypeError(`${iterable} is not iterable`));
  }

  const promises = Array.from(iterable); // 转为数组，避免多次遍历问题
  const result = new Array(promises.length);
  let resolvedCount = 0;

  // 2. 空数组直接 resolve
  if (promises.length === 0) {
    return Promise.resolve([]);
  }

  // 3. 返回一个新的 Promise
  return new Promise((resolve, reject) => {
    promises.forEach((promise, index) => {
      // 使用 Promise.resolve 包装，确保非 Promise 值也能处理
      Promise.resolve(promise)
        .then((value) => {
          result[index] = value; // 保持顺序
          resolvedCount++;
          // 所有都 resolved 才 resolve 整体
          if (resolvedCount === promises.length) {
            resolve(result);
          }
        })
        .catch((reason) => {
          // 一旦有 reject，立即 reject 整个 Promise
          reject(reason);
        });
    });
  });
}
```

# 八股文

## 闭包

### 1. 什么是闭包
   - 闭包是一个函数, 其可以记住并访问外部变量.

### 2. 闭包的作用
   - 闭包的主要作用包括数据封装、模拟私有变量、实现函数工厂和保持状态等。通过闭包，可以创建出具有独立作用域的函数，从而避免全局变量污染，提高代码的模块化和可维护性。

### 3. 闭包的使用场景
   - 闭包常用于以下场景：创建私有变量、实现函数工厂、保持状态、模拟私有变量、数据封装、实现模块化等。

### 4. 闭包的优缺点
   - 优点：数据封装、模拟私有变量、实现函数工厂、保持状态等。缺点：可能导致内存泄漏、调试困难、性能问题等。

### 5. 闭包的注意事项
   - 注意事项包括避免过度使用闭包、注意内存泄漏、理解作用域链、避免命名冲突等。合理使用闭包可以提高代码的质量和可维护性，但过度使用可能导致性能问题和调试困难。

## EventLoop
### 概念
因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。 所有同步任务都在主线程上执行，形成一个Stac）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才回读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。

## vue2和vue3的区别

#### 1. 组合式 API 解决的颗粒度的问题

- 选项式组件和响应式数据是绑定在一起的 组件 = 组件功能 + 响应式数据 包括响应式数据的变化逻辑 都是绑定在一起的没办法分割， 就是脱离组件无法书写响应式数据 ，以前只有仓库（VueX）可以把响应式数据抽出去的地方, 但是仓库又比较重 后来呢在vue3里面把响应式数据做成了一个单独的库 @vue/reactivity 跟vue组件没有任何关系、跟vue运行时没有任何关系，那就变成了出数据逻辑了就可以被抽到组件之外了

#### 2. 响应式底层实现的区别：

- vue2：通过 Object.defineProperty() 来实现数据劫持，Object.defineProperty 无法完全监听数组的所有变化，特别是在数组动态变化时。
  - 可以监听：为数组特定索引使用 Object.defineProperty 定义的属性
  - 无法监听：
    1. 未定义索引的赋值操作
    2. 数组长度变化（如 push, pop 等方法）
    3. 新增索引的赋值
- vue3：通过 Proxy 来实现数据劫持，通过 reactive() 函数来创建响应式数据

#### 3. 架构的不同：

- vue2：单文件组件（SFC）架构
- vue3：更模块化的架构设计

#### 4. 性能提升

- 更快的渲染速度：Vue 3 的虚拟 DOM 优化
- 更小的包体积：通过 Tree-shaking 减少打包体积
- 更好的响应式性能：Proxy 实现更高效的依赖追踪

#### 5. TypeScript 支持

#### 6. Teleport（传送门）

#### 7. Fragments（多根节点）

## 项目难点

1. Cesium项目中后端返回的数据量较大，之前另一个同事用dom渲染，国企浏览器版本比较低，会出现卡死情况，我改用worker并行处理数据，dom改为Primitive(图元)绘制 就好了
